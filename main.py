import config
import RPi.GPIO as GPIO
import powerCalc
import time
import paho.mqtt.client as _paho
import json

# returns the time (POSIX) for when a pulse was detected
def getNextPulse(pinNumber):
    # Start waiting for a pulse
    GPIO.wait_for_edge(pinNumber, GPIO.RISING)
    # When pulse is detected, return current time
    return time.time()

# Initialise GPIO, MQTT
def setup():
    GPIO.setmode(GPIO.BOARD)
    GPIO.setup(config.pulsePin, GPIO.IN)
    mq.on_connect = on_connect
    mq.username_pw_set(config.accessToken)
    mq.connect(config.mqttBroker, port=1883, keepalive=60)
    mq.loop_start()

# Called when MQTT client connects to the broker
def on_connect(client, userdata, flags, rc):
    print("Connected to server with result code", str(rc))

# Publish power and energy information (json format) via MQTT client
def publishPowerEnergy(power,energy):
    fPower = int(round(power, 0))   # Rounds to integer for cleaner values
    payload = json.dumps({"ts":time.time() "values":{"energy": energy, "power": fPower}})
    mq.publish(config.mqttTopicPublishPower, payload=payload, qos=1, retain=True)

# Calculate power and energy, given timestamp of last pulse, previous pulse and 
# pulses generated by powermeter per KWh consumed.
# Then also publishes calculated values
def calcAndPublish(prevP, currP, pPerKWh):
    # Calculate power and energy
    dt = currP - prevP
    power = powerCalc.timeToPower(dt=dt, pulsesPerKWh=pPerKWh)
    energy = powerCalc.pulseToEnergy(pulsesPerKWh=pPerKWh)
    # Publish both in one json string
    publishPowerEnergy(power, energy)

if __name__ == "__main__":
    mq = _paho.Client(client_id="", clean_session=True, userdata=None, protocol=_paho.MQTTv311, transport="tcp")
    setup()
    prevP = getNextPulse(config.pulsePin)   # Need a delta time for power 
    while 1:
        try:
            currP = getNextPulse(config.pulsePin)
            calcAndPublish(prevP, currP, config.pulsesPerKWh)
            prevP = currP    # Prepare previous timestamp for next run
            time.sleep(1)   # Basic ratelimiting, for when those crazy transients catch you off-guard
        except KeyboardInterrupt:
            mq.loop_stop()
            GPIO.cleanup()
            exit()