import config
import RPi.GPIO as GPIO
import powerCalc
import time
import paho.mqtt.client as _paho
import json

# Returns the time (POSIX) for when a pulse was detected
def getNextPulse(pinNumber):
    GPIO.wait_for_edge(pinNumber, GPIO.RISING)  # Start waiting for a pulse
    return time.time() 

# Initialise GPIO, MQTT
def setup():
    GPIO.setmode(GPIO.BOARD)    # Use board pin-numbering scheme
    GPIO.setup(config.pulsePin, GPIO.IN)
    mq.on_connect = on_connect
    mq.username_pw_set(config.accessToken)  # Username is used as accesstoken by Thingsboard
    mq.connect(config.mqttBroker, port=1883, keepalive=60)
    mq.loop_start()

# Called when MQTT client connects to the broker
def on_connect(client, userdata, flags, rc):
    print("Connected to server with result code", str(rc))

# Publish power and energy information (json format, with timestamp in milliseconds) via MQTT client
def publishPowerEnergy(power,energy):
    integerPower = int(round(power, 0))   # Round to integer for cleaner values
    payload = json.dumps({"ts":time.time()*1000, "values":{"energy": energy, "power": integerPower}})
    mq.publish(config.mqttTopic, payload=payload, qos=1, retain=True)

# Calculate power and energy, given timestamp of last pulse, previous pulse and pulses generated by powermeter per kWh consumed.
# Then also publishes calculated values
def calcAndPublish(prevP, currP, pPerKWh):
    dt = currP - prevP
    power = powerCalc.timeToPower(deltaTime=dt, pulsesPerKWh=pPerKWh)
    energy = powerCalc.pulseToEnergy(pulsesPerKWh=pPerKWh)
    publishPowerEnergy(power, energy)

if __name__ == "__main__":
    mq = _paho.Client(client_id="", clean_session=True, userdata=None, protocol=_paho.MQTTv311, transport="tcp")
    setup()
    prevP = getNextPulse(config.pulsePin)   # Need delta time for power calculation
    time.sleep(1) 
    while 1:
        try:
            currP = getNextPulse(config.pulsePin)
            calcAndPublish(prevP, currP, config.pulsesPerKWh)
            prevP = currP    # Prepare previous timestamp for next run
            time.sleep(config.rateLimitTime)   # Basic ratelimiting, for when those crazy transients catch you off-guard
        except KeyboardInterrupt:
            mq.loop_stop()
            GPIO.cleanup()
            exit()